import collections
print('Задачи для обязательного выполнения')
print('\n=== Task number #1 сколько учеников в классе изучают только один язык ===')
# Каждый ученик в классе изучает либо английский, либо французский, либо оба этих языка.
# У классного руководителя есть списки учеников, изучающих английский и французский языки.
# Помогите ему выяснить, сколько учеников в классе изучают только один язык.
# Формат ввода: В первых двух строках указывается количество учеников, изучающих английский и французский языки (M и N).
# Затем идут M+N строк с фамилиями учеников в произвольном порядке. Гарантируется, что среди учеников нет однофамильцев.
# Формат вывода: Количество учеников, которые изучают только один язык.
# Если таких учеников не окажется, в строке вывода нужно написать 0.
n, m = int(input('Define number of English students: ')), int(input('Define number of French students : '))
count = 0
cc = collections.Counter(list([input('Enter surname of student: ').lower() for i in range(n + m)]))
for key in cc.keys():
    if cc.get(key) == 1:
        count+=1
print('Count of students that lear only one language is:',count)

print('\n=== Task number #2 сколько мужчин-однофамильцев работает в организации ===')
# Начальник отдела кадров хочет узнать, сколько мужчин-однофамильцев работает в организации.
# Имеется список фамилий, и на основании этого списка нужно вычислить количество фамилий, которые совпадают с другими.
# Формат ввода: В первой строке указывается количество мужчин — сотрудников организации (N).
# Затем идут N строк с фамилиями этих сотрудников в произвольном порядке.
n = int(input('Define count of man workers: '))
cc = collections.Counter(list([input('Enter surname of worker: ').lower() for i in range(n)]))
count = 0
for key in cc.keys():
    if cc.get(key) > 1:
        count+= cc.get(key)
print('Count of persons bearing the same surnames is:',count)

print('\n=== Task number #3 наиболее часто встречающийся символ ===')
# Частотный анализ — это подсчёт, какие символы чаще встречаются в тексте. Это важнейший инструмент взлома
# многих классических шифров — от шифра Цезаря до шифровальной машины «Энигма».
# Выполним простой частотный анализ: выясним, какой символ чаще всего встречается в данном тексте.
# Программа запрашивает одну строку. Выводит один символ в нижнем регистре — наиболее часто встречающийся
# во введённой строке, кроме пробела, без учёта регистра, если таких несколько — выводится первый по алфавиту.
# sample = (input('Please input some text:'))
sample = 'Частотный анализ — это подсчёт, какие символы чаще встречаются в тексте. Это важнейший инструмент взлома многих классических шифров — от шифра Цезаря до шифровальной машины «Энигма».'
sample = sorted(collections.Counter(collections.deque(sample.lower().replace(" ", ''))).most_common(1))
print('Most common symbol in entered text is:',sample[0][0])

print('\nЗадачи для самостоятельного выполнения')
print('\n=== Task number #4 Числа Трибоначчи ===')
# Числа Трибоначчи — это последовательность целых чисел, которая определяется так:
# первое, второе и третье числа Трибоначчи равны единице;
# каждое следующее число Трибоначчи равно сумме трёх предыдущих.
# Напишите программу, которая вычисляет числа Трибоначчи.
# Например. Вводим 6, получаем 1 1 1 3 5 9
n = int(input('Enter number of digits Tribonacci that you want to see:'))
n1, n2, n3 = 1, 1, 1
for i in range(n):
    print(n1, end=' ')
    n1, n2, n3 = n2, n3, n1+n2+n3

print('\n\n=== Task number #5 ===')
# Напишите программу, которая будет хотя бы приблизительно определять судьбу введённого числа.
# Формат ввода: Вводится натуральное число n, меньшее миллиарда.
# Формат вывода: Начиная с числа n, умножайте имеющееся число на его первую цифру, пока у получившегося числа
# первая цифра не станет равной 1, либо пока оно не превысит миллиарда. Выведите результат.

lim = int(1000000000)
n = input('Enter digit(mus be lees than 1milion): ')
while int(collections.deque(n)[0]) != 1 & (int(n) < lim):
    n = str(int(n)*int(collections.deque(n)[0]))
    if (int(collections.deque(n)[0]) == 1) & (int(n) < lim):
        print('Output:',n+'.')
    elif int(n) > lim:
        print('Output:.')
        break
# решает согласно условия, НО по-моему тут получилось очень "накручено"...